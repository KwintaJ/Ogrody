<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ogrody</title>
    <style>
        :root {
            --bg-color: #ede6db;
            --panel-color: #f6f1ea;
            --accent: #8b5e34;
            --text-color: #3b2f2f;
            --button-bg: #e2d6c3;
            --button-hover: #d4c4ad;
            --border-color: #c8b8a0;
        }

        * {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: var(--bg-color);
            color: var(--text-color);
            animation: fadeIn 1s ease;
        }

        main {
            text-align: center;
            max-width: 800px;
            padding: 2rem;
            border-radius: 20px;
            background: white;
            box-shadow: 0 4px 25px rgba(0,0,0,0.1);
            animation: fadeIn 1.2s ease;
        }

        h1 {
            margin-bottom: 1rem;
            font-size: 1.3rem;
            letter-spacing: 0.5px;
        }

        canvas {
            width: 500px;
            height: 500px;
            max-width: 100%;
            border: 2px solid var(--accent);
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            transition: border-color 0.3s ease;
        }

        .nav {
            margin-top: 4rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .nav a {
            text-decoration: none;
            padding: 0.6rem 1.3rem;
            border-radius: 8px;
            background: var(--button-bg);
            color: var(--accent);
            font-weight: 600;
            transition: background 0.3s, transform 0.2s;
        }

        .nav a:hover {
            background: var(--button-hover);
            transform: translateY(-2px);
        }

        .dimensions {
            margin-top: 1.5rem;
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .dimensions label {
            display: flex;
            flex-direction: column;
            font-size: 0.85rem;
            color: var(--text-color);
        }

        .dimensions input {
            margin-top: 0.3rem;
            padding: 0.4rem 0.6rem;
            width: 90px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: white;
            font-size: 0.9rem;
        }

        footer {
            align-items: center;
            margin-top: 8.5rem;
            font-size: 0.85rem;
            color: #666;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>

    <h1>Projekt ogrodu</h1>
    <canvas id="canvas" width="500" height="500"></canvas>

    <div class="nav">
        <a id="generateButton">Generuj</a>
        <a href="https://kwintaj.github.io/Ogrody/">Powrót</a>
    </div>

    <div class="dimensions">
        <label>
            Szerokość (m):
            <input type="number" id="widthInput" value="50" min="1">
        </label>
        <label>
            Wysokość (m):
            <input type="number" id="heightInput" value="50" min="1">
        </label>
    </div>

    <footer>
        © 2025 Jan Kwinta — Ogrody: Gramatyka grafowa
    </footer>

<script>
    //=========================================================
    // canvas glowne
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    //=========================================================
    // zmiana wymiarow ogrodu
    const PX_PER_METER = 10;
    const dpr = window.devicePixelRatio || 1;
    function resizeCanvas() {
        widthMeters = Number(document.getElementById("widthInput").value);
        heightMeters = Number(document.getElementById("heightInput").value);

        if (widthMeters >= 75) {
            widthMeters = 75;
        }
        if (heightMeters >= 60) {
            heightMeters = 60;
        }
        if (widthMeters <= 10) {
            widthMeters = 10;
        }
        if (heightMeters <= 10) {
            heightMeters = 10;
        }

        const widthPx = widthMeters * PX_PER_METER;
        const heightPx = heightMeters * PX_PER_METER;

        canvas.width = widthPx * dpr;
        canvas.height = heightPx * dpr;

        canvas.style.width = widthPx + "px";
        canvas.style.height = heightPx + "px";

        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, widthPx, heightPx);        
    }
    document.getElementById("widthInput").addEventListener("click", resizeCanvas);
    document.getElementById("heightInput").addEventListener("click", resizeCanvas);
    document.getElementById("widthInput").addEventListener("keypress", resizeCanvas);
    document.getElementById("heightInput").addEventListener("keypress", resizeCanvas);
    resizeCanvas();

    //=========================================================
    // klasy i funkcje rysowania ogrodu
    const Type = {
        GRASS: "GRASS",
        PATH: "PATH",
        FLOWERS: "FLOWERS",
        TREE: "TREE",
        BENCH: "BENCH",
        WATER: "WATER",
        NULL: "NULL"
    }

    const METER = 10; 
    function drawTile(x, y, type) {
        switch (type) {
            case Type.GRASS:
                ctx.fillStyle = "#7ec850";
                ctx.fillRect(x, y, METER, METER);

                ctx.fillStyle = "#5fa63c";
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(
                        x + Math.random() * METER,
                        y + Math.random() * METER,
                        1,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }
                break;

            case Type.PATH:
                ctx.fillStyle = "#b0b0b0";
                ctx.fillRect(x, y, METER, METER);

                ctx.fillStyle = "#8a6a3d";
                for (let i = 0; i < 2; i++) {
                    ctx.fillRect(
                        x + Math.random() * METER,
                        y + Math.random() * METER,
                        2,
                        2
                    );
                }
                break;

            case Type.WATER:
                ctx.fillStyle = "#6ec6ff";
                ctx.fillRect(x, y, METER, METER);

                ctx.strokeStyle = "#4fa3d1";
                ctx.beginPath();
                ctx.moveTo(x, y + 5);
                ctx.lineTo(x + METER, y + 5);
                ctx.stroke();
                break;

            case Type.TREE:
                ctx.fillStyle = "#2e7d32";
                ctx.fillRect(x, y, METER, METER);
                break;

            case Type.FLOWERS:
                ctx.fillStyle = "#ffc0cb";
                ctx.fillRect(x, y, METER, METER);

                ctx.fillStyle = ["red", "yellow", "purple", "white"][
                    Math.floor(Math.random() * 4)
                ];
                ctx.beginPath();
                ctx.arc(x + 5, y + 5, 2, 0, Math.PI * 2);
                ctx.fill();
                break;

            case Type.BENCH:
                ctx.fillStyle = "#8d6e63";
                ctx.fillRect(x, y, METER, METER);
                break;
        }
    }

    class Rectangle {
        constructor(x, y, w, h, t) {
            this.x = Math.round(x / 10) * 10;
            this.y = Math.round(y / 10) * 10;
            this.w = Math.round(w / 10) * 10;
            this.h = Math.round(h / 10) * 10;
            this.t = t;
        }

        draw() {
            // console.log(this);
            for (let px = this.x; px < this.x + this.w; px += METER) {
                for (let py = this.y; py < this.y + this.h; py += METER) {
                    drawTile(px, py, this.t);
                }
            }
        }
    }

    class Circle {
        constructor(x, y, r, t) {
            this.x = x;
            this.y = y;
            this.r = r;
            this.t = t;
        }

        draw() {
            switch (this.t) {
                case Type.GRASS:
                    ctx.fillStyle = "#7ec850";
                    break;
                case Type.WATER:
                    ctx.fillStyle = "#6ec6ff";
                    break;
                case Type.TREE:
                    ctx.fillStyle = "#2e7d32";
                    break;
                case Type.FLOWERS:
                    ctx.fillStyle = "#ffc0cb";
                    break;
                case Type.PATH:
                    ctx.fillStyle = "#b0b0b0";
                    break;
                case Type.BENCH:
                    ctx.fillStyle = "#8d6e63";
                    break;
            }

            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            ctx.fill();

            if (this.t === Type.TREE) {
                ctx.strokeStyle = "#1b4d1b";
                ctx.lineWidth = 4;
                ctx.stroke();
            }

            for (let px = this.x - this.r; px < this.x + this.r; px += METER) {
                for (let py = this.y - this.r; py < this.y + this.r; py += METER) {
                    const dx = px + METER / 2 - this.x;
                    const dy = py + METER / 2 - this.y;
                    if (dx * dx + dy * dy <= (this.r - 10) * (this.r - 10)) {
                        drawTile(px, py, this.t);
                    }
                }
            }
        }
    }

    //=========================================================
    // klasa ogrod do generowania grafu gramatyka
    class Garden {
        constructor() {
            this.graph = [];
            this.DIVISION_COEFF = 4;
        }

        // generuje caly ogrod
        randomGenerate() {
            this.grassRandomDivide(new Rectangle(10, 10, canvas.width - 20, canvas.height - 20, Type.GRASS), this.DIVISION_COEFF);
            this.addPaths();
            this.addWaterFeature();
        }

        //=========================================================
        // reguly gramatyki grafowej

        // podstawowy pseudolosowy podzial trawnika
        grassRandomDivide(R, n) {
            if (n == 1) {
                this.graph.push(R);
                return;
            }

            let newDiv = [];
            let grass1, grass2;

            // w podzialach nierownych (2:3 i 3:2) dzielimy dalej 
            // wieksza czesc; w podzialach rownych losujemy
            // chcemy dzielic "chude" fragmenty ladnie

            let slice;
            if (R.w > R.h * 1.3) {
                slice = Math.floor(Math.random() * 4);
            }
            else if (R.h > R.w * 1.3) {
                slice = Math.floor(Math.random() * 4) + 4;
            }
            else {
                slice = Math.floor(Math.random() * 8);
            }

            switch (slice) {
                // podzialy wertykalnie
                case 0: // 1:1 dzielimy 1
                    grass1 = new Rectangle(R.x, R.y, R.w * 0.5, R.h, Type.GRASS);
                    grass2 = new Rectangle(R.x + R.w * 0.5, R.y, R.w * 0.5, R.h, Type.GRASS);
                    newDiv.push(grass2);
                    newDiv.push.apply(newDiv, this.grassRandomDivide(grass1, n - 1));
                    break;
                case 1: // 1:1 dzielimy 2
                    grass1 = new Rectangle(R.x, R.y, R.w * 0.5, R.h, Type.GRASS);
                    grass2 = new Rectangle(R.x + R.w * 0.5, R.y, R.w * 0.5, R.h, Type.GRASS);
                    newDiv.push(grass1);
                    newDiv.push.apply(newDiv, this.grassRandomDivide(grass2, n - 1));
                    break;
                case 2: // 3:2
                    grass1 = new Rectangle(R.x, R.y, R.w * 0.6, R.h, Type.GRASS);
                    grass2 = new Rectangle(R.x + R.w * 0.6, R.y, R.w * 0.4, R.h, Type.GRASS);
                    newDiv.push(grass2);
                    newDiv.push.apply(newDiv, this.grassRandomDivide(grass1, n - 1));
                    break;
                case 3: // 2:3
                    grass1 = new Rectangle(R.x, R.y, R.w * 0.4, R.h, Type.GRASS);
                    grass2 = new Rectangle(R.x + R.w * 0.4, R.y, R.w * 0.6, R.h, Type.GRASS);
                    newDiv.push(grass1);
                    newDiv.push.apply(newDiv, this.grassRandomDivide(grass2, n - 1));
                    break;
                // podzialy horyzontalnie
                case 4: // 1:1 dzielimy 1
                    grass1 = new Rectangle(R.x, R.y, R.w, R.h * 0.5, Type.GRASS);
                    grass2 = new Rectangle(R.x, R.y + R.h * 0.5, R.w, R.h * 0.5, Type.GRASS);
                    newDiv.push(grass2);
                    newDiv.push.apply(newDiv, this.grassRandomDivide(grass1, n - 1));
                    break;
                case 5: // 1:1 dzielimy 2
                    grass1 = new Rectangle(R.x, R.y, R.w, R.h * 0.5, Type.GRASS);
                    grass2 = new Rectangle(R.x, R.y + R.h * 0.5, R.w, R.h * 0.5, Type.GRASS);
                    newDiv.push(grass1);
                    newDiv.push.apply(newDiv, this.grassRandomDivide(grass2, n - 1));
                    break;
                case 6: // 3:2
                    grass1 = new Rectangle(R.x, R.y, R.w, R.h * 0.6, Type.GRASS);
                    grass2 = new Rectangle(R.x, R.y + R.h * 0.6, R.w, R.h * 0.4, Type.GRASS);
                    newDiv.push(grass2);
                    newDiv.push.apply(newDiv, this.grassRandomDivide(grass1, n - 1));
                    break;
                case 7: // 2:3
                    grass1 = new Rectangle(R.x, R.y, R.w, R.h * 0.4, Type.GRASS);
                    grass2 = new Rectangle(R.x, R.y + R.h * 0.4, R.w, R.h * 0.6, Type.GRASS);
                    newDiv.push(grass1);
                    newDiv.push.apply(newDiv, this.grassRandomDivide(grass2, n - 1));
                    break;
            }

            this.graph.push.apply(this.graph, newDiv);
        }   

        // sciezki naokolo kazdego z wydzielonych fragmentow trawnika
        addPaths() {
            this.graph.push.apply(this.graph, [
                new Rectangle(0, 0, canvas.width, 10, Type.PATH),
                new Rectangle(0, 0, 10, canvas.height, Type.PATH),
                new Rectangle(canvas.width - 10, 0, 10, canvas.height, Type.PATH),
                new Rectangle(0, canvas.height - 10, canvas.width, 10, Type.PATH)
            ]);

            for (let i = 0; i < this.graph.length; i++) {
                if (this.graph[i].t == Type.GRASS) {
                    let OG = this.graph[i]; // oldGrass
                    let newGrass, newPath1, newPath2, newPath3, newPath4;

                    newGrass = new Rectangle(OG.x + 10, OG.y + 10, OG.w - 20, OG.h - 20, OG.t);
                    newPath1 = new Rectangle(OG.x, OG.y, 10, OG.h, Type.PATH);
                    newPath2 = new Rectangle(OG.x, OG.y, OG.w, 10, Type.PATH);
                    newPath3 = new Rectangle(OG.x + OG.w - 10, OG.y, 10, OG.h, Type.PATH);
                    newPath4 = new Rectangle(OG.x, OG.y + OG.h - 10, OG.w, 10, Type.PATH);
                    
                    this.graph.splice(i, 1, newGrass, newPath1, newPath2, newPath3, newPath4);
                    i++;
                }
            }
        }

        // dodawanie oczek wodnych: koło, owale, rzeczka albo brak
        addWaterFeature() {
            let biggestGrass = new Rectangle(-1, -1, 0, 0, Type.NULL);
            for (let i = 1; i < this.graph.length; i++) {
                if(this.graph[i] instanceof Rectangle &&
                    this.graph[i].w * this.graph[i].h > biggestGrass.w * biggestGrass.h) {
                        biggestGrass = this.graph[i]; 
                }
            }

            let offsetX = (Math.floor(Math.random() * biggestGrass.w / 20) - (biggestGrass.w / 40)) * 10;
            let offsetY = (Math.floor(Math.random() * biggestGrass.h / 20) - (biggestGrass.h / 40)) * 10;
            let middleX = biggestGrass.x + (biggestGrass.w / 2) + offsetX;
            let middleY = biggestGrass.y + (biggestGrass.h / 2) + offsetY;
            let offsetR = (Math.floor(Math.random() * 2) - 1) * 10;
            let nR;

            let featureType = Math.floor(Math.random() * 5);
            switch (featureType) {
                case 0: // kolo
                    this.graph.push(new Circle(middleX, middleY, 70 + offsetR, Type.WATER));
                    break;
                case 1: // owal 1
                    let nXa = (middleX + 35) - ((middleX + 35) % 10);
                    let nXb = (middleX - 35) - ((middleX - 35) % 10);
                    let nY = (middleY) - ((middleY) % 10);
                    nR = (60 + offsetR) - ((60 + offsetR) % 10);
                    this.graph.push(new Circle(nXa, nY, nR, Type.WATER));
                    this.graph.push(new Circle(nXb, nY, nR, Type.WATER));
                    this.graph.push(new Rectangle(nXb, nY - nR, 70, 2 * nR, Type.WATER));
                    break;
                case 2: // owal 2
                    let nYa = (middleY + 35) - ((middleY + 35) % 10);
                    let nYb = (middleY - 35) - ((middleY - 35) % 10);
                    let nX = (middleX) - ((middleX) % 10);
                    nR = (60 + offsetR) - ((60 + offsetR) % 10);
                    this.graph.push(new Circle(nX, nYa, nR, Type.WATER));
                    this.graph.push(new Circle(nX, nYb, nR, Type.WATER));
                    this.graph.push(new Rectangle(nX - nR, nYb, 2 * nR, 70, Type.WATER));
                    break;
                case 3: // rzeczka
                    if (biggestGrass.w >= biggestGrass.h) {
                        let chunk = (biggestGrass.w / 8) - ((biggestGrass.w / 8) % 10);
                        let lastChunk = biggestGrass.w - (7 * chunk);
                        this.graph.push(new Rectangle(biggestGrass.x, middleY + 10, chunk, 20, Type.WATER));
                        this.graph.push(new Rectangle(biggestGrass.x + chunk, middleY + 20, chunk, 20, Type.WATER));
                        this.graph.push(new Rectangle(biggestGrass.x + (2 * chunk), middleY + 10, chunk, 20, Type.WATER));
                        this.graph.push(new Rectangle(biggestGrass.x + (3 * chunk), middleY, chunk, 20, Type.WATER));
                        this.graph.push(new Rectangle(biggestGrass.x + (4 * chunk), middleY - 10, chunk, 20, Type.WATER));
                        this.graph.push(new Rectangle(biggestGrass.x + (5 * chunk), middleY - 20, chunk, 20, Type.WATER));
                        this.graph.push(new Rectangle(biggestGrass.x + (6 * chunk), middleY - 10, chunk, 20, Type.WATER));
                        this.graph.push(new Rectangle(biggestGrass.x + (7 * chunk), middleY, lastChunk, 20, Type.WATER));
                    }
                    else {
                        let chunk = (biggestGrass.h / 8) - ((biggestGrass.h / 8) % 10);
                        let lastChunk = biggestGrass.h - (7 * chunk);
                        this.graph.push(new Rectangle(middleX + 10, biggestGrass.y, 20, chunk, Type.WATER));
                        this.graph.push(new Rectangle(middleX + 20, biggestGrass.y + chunk, 20, chunk, Type.WATER));
                        this.graph.push(new Rectangle(middleX + 10, biggestGrass.y + (2 * chunk), 20, chunk, Type.WATER));
                        this.graph.push(new Rectangle(middleX, biggestGrass.y + (3 * chunk), 20, chunk, Type.WATER));
                        this.graph.push(new Rectangle(middleX - 10, biggestGrass.y + (4 * chunk), 20, chunk, Type.WATER));
                        this.graph.push(new Rectangle(middleX - 20, biggestGrass.y + (5 * chunk), 20, chunk, Type.WATER));
                        this.graph.push(new Rectangle(middleX - 10, biggestGrass.y + (6 * chunk), 20, chunk, Type.WATER));
                        this.graph.push(new Rectangle(middleX, biggestGrass.y + (7 * chunk), 20, lastChunk, Type.WATER));
                    }
                    break;
                case 4: // nic
                    break;
            }
        }


        //=========================================================
        // funkcje pomocnicze

        //=========================================================
        // rysowanie
        draw() {
            for (let i = 0; i < this.graph.length; i++) {
                if (this.graph[i].t == Type.GRASS) {
                    this.graph[i].draw();
                }
            }

            for (let i = 0; i < this.graph.length; i++) {
                if (this.graph[i].t == Type.WATER) {
                    this.graph[i].draw();
                }
            }

            for (let i = 0; i < this.graph.length; i++) {
                if (this.graph[i].t == Type.PATH) {
                    this.graph[i].draw();
                }
            }
        }
    }

    //=========================================================
    // generowanie ogrodu
    document.getElementById("generateButton").addEventListener("click", (event) => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        let g = new Garden();
        g.randomGenerate();
        g.draw();
    });

</script>

</body>
</html>
