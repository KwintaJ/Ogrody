<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ogrody</title>
    <style>
        :root {
            --bg-color: #ede6db;
            --panel-color: #f6f1ea;
            --accent: #8b5e34;
            --text-color: #3b2f2f;
            --button-bg: #e2d6c3;
            --button-hover: #d4c4ad;
            --border-color: #c8b8a0;
        }

        * {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: var(--bg-color);
            color: var(--text-color);
            animation: fadeIn 1s ease;
        }

        main {
            text-align: center;
            max-width: 800px;
            padding: 2rem;
            border-radius: 20px;
            background: white;
            box-shadow: 0 4px 25px rgba(0,0,0,0.1);
            animation: fadeIn 1.2s ease;
        }

        h1 {
            margin-bottom: 1rem;
            font-size: 1.3rem;
            letter-spacing: 0.5px;
        }

        canvas {
            width: 500px;
            height: 500px;
            max-width: 100%;
            border: 2px solid var(--accent);
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            transition: border-color 0.3s ease;
        }

        .nav {
            margin-top: 4rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .nav a {
            text-decoration: none;
            padding: 0.6rem 1.3rem;
            border-radius: 8px;
            background: var(--button-bg);
            color: var(--accent);
            font-weight: 600;
            transition: background 0.3s, transform 0.2s;
        }

        .nav a:hover {
            background: var(--button-hover);
            transform: translateY(-2px);
        }

        .dimensions {
            margin-top: 1.5rem;
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .dimensions label {
            display: flex;
            flex-direction: column;
            font-size: 0.85rem;
            color: var(--text-color);
        }

        .dimensions input {
            margin-top: 0.3rem;
            padding: 0.4rem 0.6rem;
            width: 90px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: white;
            font-size: 0.9rem;
        }

        footer {
            align-items: center;
            margin-top: 8.5rem;
            font-size: 0.85rem;
            color: #666;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>

    <h1>Projekt ogrodu</h1>
    <canvas id="canvas" width="500" height="500"></canvas>

    <div class="nav">
        <a id="generateButton">Generuj</a>
        <a href="https://kwintaj.github.io/Ogrody/">Powrót</a>
    </div>

    <div class="dimensions">
        <label>
            Szerokość (m):
            <input type="number" id="widthInput" value="50" min="1">
        </label>
        <label>
            Wysokość (m):
            <input type="number" id="heightInput" value="50" min="1">
        </label>
    </div>

    <footer>
        © 2025 Jan Kwinta — Ogrody: Gramatyka grafowa
    </footer>

<script>
    //=========================================================
    // canvas glowne
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    //=========================================================
    // zmiana wymiarow ogrodu
    const PX_PER_METER = 10;
    const dpr = window.devicePixelRatio || 1;
    function resizeCanvas() {
        widthMeters = Number(document.getElementById("widthInput").value);
        heightMeters = Number(document.getElementById("heightInput").value);

        if (widthMeters >= 75) {
            widthMeters = 75;
        }
        if (heightMeters >= 60) {
            heightMeters = 60;
        }
        if (widthMeters <= 10) {
            widthMeters = 10;
        }
        if (heightMeters <= 10) {
            heightMeters = 10;
        }

        const widthPx = widthMeters * PX_PER_METER;
        const heightPx = heightMeters * PX_PER_METER;

        canvas.width = widthPx * dpr;
        canvas.height = heightPx * dpr;

        canvas.style.width = widthPx + "px";
        canvas.style.height = heightPx + "px";

        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, widthPx, heightPx);        
    }
    document.getElementById("widthInput").addEventListener("click", resizeCanvas);
    document.getElementById("heightInput").addEventListener("click", resizeCanvas);
    document.getElementById("widthInput").addEventListener("keypress", resizeCanvas);
    document.getElementById("heightInput").addEventListener("keypress", resizeCanvas);
    resizeCanvas();

    //=========================================================
    // klasy i funkcje rysowania ogrodu
    const Type = {
        GRASS: "GRASS",
        PATH: "PATH",
        FLOWERS: "FLOWERS",
        TREE: "TREE",
        BENCH: "BENCH",
        WATER: "WATER"
    }

    const METER = 10; 
    function drawTile(x, y, type) {
        switch (type) {
            case Type.GRASS:
                ctx.fillStyle = "#7ec850";
                ctx.fillRect(x, y, METER, METER);

                ctx.fillStyle = "#5fa63c";
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(
                        x + Math.random() * METER,
                        y + Math.random() * METER,
                        1,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }
                break;

            case Type.PATH:
                ctx.fillStyle = "#b0b0b0";
                ctx.fillRect(x, y, METER, METER);

                ctx.fillStyle = "#8a6a3d";
                for (let i = 0; i < 2; i++) {
                    ctx.fillRect(
                        x + Math.random() * METER,
                        y + Math.random() * METER,
                        2,
                        2
                    );
                }
                break;

            case Type.WATER:
                ctx.fillStyle = "#6ec6ff";
                ctx.fillRect(x, y, METER, METER);

                ctx.strokeStyle = "#4fa3d1";
                ctx.beginPath();
                ctx.moveTo(x, y + 5);
                ctx.lineTo(x + METER, y + 5);
                ctx.stroke();
                break;

            case Type.TREE:
                ctx.fillStyle = "#2e7d32";
                ctx.fillRect(x, y, METER, METER);
                break;

            case Type.FLOWERS:
                ctx.fillStyle = "#ffc0cb";
                ctx.fillRect(x, y, METER, METER);

                ctx.fillStyle = ["red", "yellow", "purple", "white"][
                    Math.floor(Math.random() * 4)
                ];
                ctx.beginPath();
                ctx.arc(x + 5, y + 5, 2, 0, Math.PI * 2);
                ctx.fill();
                break;

            case Type.BENCH:
                ctx.fillStyle = "#8d6e63";
                ctx.fillRect(x, y, METER, METER);
                break;
        }
    }

    class Rectangle {
        constructor(x, y, w, h, t) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
            this.t = t;
        }

        draw() {
            console.log(this);
            for (let px = this.x; px < this.x + this.w; px += METER) {
                for (let py = this.y; py < this.y + this.h; py += METER) {
                    drawTile(px, py, this.t);
                }
            }
        }
    }

    class Circle {
        constructor(x, y, r, t) {
            this.x = x;
            this.y = y;
            this.r = r;
            this.t = t;
        }

        draw() {
            switch (this.t) {
                case Type.GRASS:
                    ctx.fillStyle = "#7ec850";
                    break;
                case Type.WATER:
                    ctx.fillStyle = "#6ec6ff";
                    break;
                case Type.TREE:
                    ctx.fillStyle = "#2e7d32";
                    break;
                case Type.FLOWERS:
                    ctx.fillStyle = "#ffc0cb";
                    break;
                case Type.PATH:
                    ctx.fillStyle = "#b0b0b0";
                    break;
                case Type.BENCH:
                    ctx.fillStyle = "#8d6e63";
                    break;
            }

            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            ctx.fill();

            if (this.t === Type.TREE) {
                ctx.strokeStyle = "#1b4d1b";
                ctx.lineWidth = 4;
                ctx.stroke();
            }

            for (let px = this.x - this.r; px < this.x + this.r; px += METER) {
                for (let py = this.y - this.r; py < this.y + this.r; py += METER) {
                    const dx = px + METER / 2 - this.x;
                    const dy = py + METER / 2 - this.y;
                    if (dx * dx + dy * dy <= (this.r - 10) * (this.r - 10)) {
                        drawTile(px, py, this.t);
                    }
                }
            }
        }
    }

    //=========================================================
    // reguly - funkcje generowania ogrodu

    // podstawowy pseudolosowy podzial trawnika
    function grassRandomDivide(R, n) {
        if (n == 1) {
            return [R];
        }

        let newDiv = [];
        let grass1, grass2;

        // w podzialach nierownych (2:3 i 3:2) dzielimy dalej 
        // wieksza czesc; w podzialach rownych losujemy
        const randomChoice = Math.floor(Math.random() * 8);
        switch (randomChoice) {
            // podzialy wertykalnie
            case 0: // 1:1 dzielimy 1
                grass1 = new Rectangle(R.x, R.y, R.w * 0.5, R.h, Type.GRASS);
                grass2 = new Rectangle(R.x + R.w * 0.5, R.y, R.w * 0.5, R.h, Type.GRASS);
                newDiv.push(grass2);
                newDiv.push.apply(newDiv, grassRandomDivide(grass1, n - 1));
                break;
            case 1: // 1:1 dzielimy 2
                grass1 = new Rectangle(R.x, R.y, R.w * 0.5, R.h, Type.GRASS);
                grass2 = new Rectangle(R.x + R.w * 0.5, R.y, R.w * 0.5, R.h, Type.GRASS);
                newDiv.push(grass1);
                newDiv.push.apply(newDiv, grassRandomDivide(grass2, n - 1));
                break;
            case 2: // 3:2
                grass1 = new Rectangle(R.x, R.y, R.w * 0.6, R.h, Type.GRASS);
                grass2 = new Rectangle(R.x + R.w * 0.6, R.y, R.w * 0.4, R.h, Type.GRASS);
                newDiv.push(grass2);
                newDiv.push.apply(newDiv, grassRandomDivide(grass1, n - 1));
                break;
            case 3: // 2:3
                grass1 = new Rectangle(R.x, R.y, R.w * 0.4, R.h, Type.GRASS);
                grass2 = new Rectangle(R.x + R.w * 0.4, R.y, R.w * 0.6, R.h, Type.GRASS);
                newDiv.push(grass1);
                newDiv.push.apply(newDiv, grassRandomDivide(grass2, n - 1));
                break;
            // podzialy horyzontalnie
            case 4: // 1:1 dzielimy 1
                grass1 = new Rectangle(R.x, R.y, R.w, R.h * 0.5, Type.GRASS);
                grass2 = new Rectangle(R.x, R.y + R.h * 0.5, R.w, R.h * 0.5, Type.GRASS);
                newDiv.push(grass2);
                newDiv.push.apply(newDiv, grassRandomDivide(grass1, n - 1));
                break;
            case 5: // 1:1 dzielimy 2
                grass1 = new Rectangle(R.x, R.y, R.w, R.h * 0.5, Type.GRASS);
                grass2 = new Rectangle(R.x, R.y + R.h * 0.5, R.w, R.h * 0.5, Type.GRASS);
                newDiv.push(grass1);
                newDiv.push.apply(newDiv, grassRandomDivide(grass2, n - 1));
                break;
            case 6: // 3:2
                grass1 = new Rectangle(R.x, R.y, R.w, R.h * 0.6, Type.GRASS);
                grass2 = new Rectangle(R.x, R.y + R.h * 0.6, R.w, R.h * 0.4, Type.GRASS);
                newDiv.push(grass2);
                newDiv.push.apply(newDiv, grassRandomDivide(grass1, n - 1));
                break;
            case 7: // 2:3
                grass1 = new Rectangle(R.x, R.y, R.w, R.h * 0.4, Type.GRASS);
                grass2 = new Rectangle(R.x, R.y + R.h * 0.4, R.w, R.h * 0.6, Type.GRASS);
                newDiv.push(grass1);
                newDiv.push.apply(newDiv, grassRandomDivide(grass2, n - 1));
                break;
        }

        return newDiv;
    }

    function addPaths(G) {
        if (G.length <= 1) {
            return G;
        }

        for (let i = 0; i < G.length; i++) {
            if (G[i].t == Type.GRASS && Math.random() > 0.5) {
                let OG = G[i]; // oldGrass
                let newGrass, newPath;

                let pathCreated = false;

                while (!pathCreated) {
                    let randomChoice = Math.floor(Math.random() * 4);
                    switch (randomChoice) {
                        case 0:
                            if (OG.x > 0) {
                                newGrass = new Rectangle(OG.x + 10, OG.y, OG.w - 10, OG.h, OG.t);
                                newPath = new Rectangle(OG.x, OG.y, 10, OG.h, Type.PATH);
                                pathCreated = true;
                            }
                            break;
                        case 1:
                            if (OG.y > 0) {
                                newGrass = new Rectangle(OG.x, OG.y + 10, OG.w, OG.h - 10, OG.t);
                                newPath = new Rectangle(OG.x, OG.y, OG.w, 10, Type.PATH);
                                pathCreated = true;
                            }
                            break;
                        case 2:
                            if (OG.x + OG.w < canvas.width) {
                                newGrass = new Rectangle(OG.x, OG.y, OG.w - 10, OG.h, OG.t);
                                newPath = new Rectangle(OG.x + OG.w - 10, OG.y, 10, OG.h, Type.PATH);
                                pathCreated = true;
                            }
                            break;
                        case 3:
                            if (OG.y + OG.h < canvas.height) {
                                newGrass = new Rectangle(OG.x, OG.y, OG.w, OG.h - 10, OG.t);
                                newPath = new Rectangle(OG.x, OG.y + OG.h - 10, OG.w, 10, Type.PATH);
                                pathCreated = true;
                            }
                            break;
                    }
                }
                G.splice(i, 1, newGrass, newPath);
                i++;
            }
        }

        return G;
    }

    //=========================================================
    // klasa ogrod
    class Garden {
        constructor() {
            this.grass0 = new Rectangle(0, 0, canvas.width, canvas.height, Type.GRASS);
            this.graph = []
        }

        randomGenerate() {
            this.graph.push.apply(this.graph, grassRandomDivide(this.grass0, 5));
            this.graph = addPaths(this.graph);
        }

        draw() {
            for (let i = 0; i < this.graph.length; i++) {
                if (this.graph[i] instanceof Rectangle) {
                    this.graph[i].draw();
                }
            }

            for (let i = 0; i < this.graph.length; i++) {
                if (this.graph[i] instanceof Circle) {
                    console.log(this.graph[i]);
                    this.graph[i].draw();
                }
            }
        }
    }

    //=========================================================
    // generowanie ogrodu
    document.getElementById("generateButton").addEventListener("click", (event) => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        let g = new Garden();
        g.randomGenerate();
        g.draw();
    });

</script>

</body>
</html>
